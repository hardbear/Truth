# Summary

![Progress](http://progressed.io/bar/5?title=Difficulty:2400|Solved:<1000)

|　　一　　|　　二　　|　　三　　|　　四　　|　　五　　|　　六　　|　　日　　|
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|      |      |  1   | 2 |  3   |  4   |  5   |
|      |      |      |  ✔2  |      |  ✔1  | ✔1 |
|  6   |  7   |  8   |  9   |  10  |  11  |  12  |
| ✔1 |      |      |      |      |      |      |
|  13  |  14  |  15  |  16  |  17  |  18  |  19  |
|      |      |      |      |      |      |      |
|  20  |  21  |  22  |  23  |  24  |  25  |  26  |
|      |      |      |      |      | ⭐ |      |
|  27  |  28  |  29  |  30  |  31  |      |      |
|      |      |      |      |      |      |      |

---

# Draft

## 【Difficulty : 2400 | Solved : < 1000】

### 2019.05.06

#### ✔ Codeforces 711E

**题意**

1. 一年有 2^n 天
2. k 个人
3. 至少两个人同一天生日的概率
4. 用最简分数表示

**思考**

P（至少两个人） = 1 - P（都不同）= 1 - A（2^n，k）/ (2^(n*k))

A = (2 ^ n) - i (0 ~ i ~ k-1)

不会做

看题解

式子还是上面的式子

要让 a/b 最简，等价于让 (b-a)/b 最简，因为 gcd(a, b) = gcd(b-a, b)

所以考虑化简 P（都不同）

因为分母是 2 的幂，所以最大公因数应是 2 的尽可能高次幂

使其能整除分子。

STOP！

思考的过程应该是：步骤一，因为原因1，推导出步骤二，以此类推

1. $$
   ans = P_1(至少两个人) = 1 - P_2(都不同)
   $$

2. $$
   目的：化简分数\ P_1
   $$

3. $$
   等价于化简 P_2
   $$

   

4. $$
   P_2 = \frac{A(2^n, k)}{2^{nk}} = \frac{(2^n-1)(2^n-2)...(2^n-(k-1))}{2^{n(k-1)}}
   $$

5. $$
   ∵\ 分母\ ∴\ 最大公因数 g = 2^i
   $$

6. $$
   求最大的\ i\ 使得\ 2^i\ 整除分子
   $$

7. $$
   设\ p_j\ 为最大的指数使得\ 2^{p_j}\ 整除\ (2^n-j)
   $$

8. $$
   则\ i = \sum_jp_j
   $$

9. $$
   设\ 2^{p_j} | (2^n-j) ，又∵\ 2^{p_j} | 2^n\ ，∴2^{p_j} | j
   $$

10. $$
    ∴\ 转化为求最大的\ i\ 使得\ 2^i\ 整除\ (k-1)!
    $$

11. $$
    勒让德定理：\\
    L_p(n!)=\sum_{k\ge1}\lfloor\frac{n}{p^k}\rfloor\qquad 表示\ n!\ 中素数\ p\ 的最高指数
    $$

12. $$
    则\ i = L_2((k-1)!)
    $$

13. $$
    那么，现在得到了化简\ P_2\ 的最大公因数\ g = 2^i
    $$

14. $$
    现在要求分子和分母整除\ g\ 的值
    $$

15. $$
    对于分子\\∵\ 连续超过\ MOD\ 个数必有一个是\ MOD\ 的倍数，\\∴\ 只需要在(k-1)<MOD\ 时计算
    $$

16. $$
    对于分母\\
    分开计算指数\ n\ 和\ (k-1)\ ，防止溢出
    $$

17. $$
    如果 k > 2^n 直接输出\ 1\ 1
    $$



---


### 2019.05.05

#### ✔ Codeforces 379F (LCA)

**题意**

1. 初始一颗三叉树
2. 之后每次询问，选择一个结点，加上两个子节点
3. 求每次询问时树的直径

**思考**

求树的直径，复杂度是 O（n）

每次加入一个结点，增加分支高度

分为三支，2，3，4

每次询问，输出三支中最高两支之和

不对！

直径也可能在同一分支内，不一定要经过根节点 1

看了评论区题解

维护当前直径的两个端点，然后每次新添加的点，和两个端点比较，如果形成的新直径更长，更新答案

其实可以一次性把所有点都加入，然后算最近公共祖先，再回过头回答每个询问

试试看

忘了每次加两个结点，N 要开两倍

第一次 RE， 第二次 AC

---


### 2019.05.04

#### ✔ Codeforces 1107G (ST表 + 单调栈)

**题意**

求区间 L 和 R 使得 (R - L + 1) * a - c(R, L) - maxd(R, L) 最大

**思考**

1. 预处理 ans = max(ans, a[i] - c[i], 0)
2. dd[i] = d[i] - d[i-1]
3. 对于每个 i ，找到左右两边第一个 dd[j] > dd[i] ，即每个 i 对应一个 l[i]，r[i]
4. 预处理 pre[i] = pre[i-1] + a - c[i]
5. 以 dd[i] 为最大值 maxd，在 l[i] 和 r[i] 的范围内找最大和最小的 pre
6. 在纸上画了应询问的区间

**总结**

ST 表区间涉及端点 0 ，但板子没考虑端点 0

---


### 2019.05.02

#### ✔ Codeforces 145E (线段树)

**题意**

长度为 n 的字符串，只由 4 和 7 组成。

m 次操作：

1. 区间 [l, r] 内，4 变 7，7 变 4
2. 求整个字符串的最长非严格上升子序列，并输出长度

**思考**

本来没想法，百度，看到关键词，线段树，没看题解！就会做了！

---

#### ✔ Codeforces 584E (排列组合 + 构造)

**题意**

两个排列 p 和 s ，每次交换 pi 和 pj ，花费 abs(i-j) ，求最少花费使 p 变成 s ，且输出方案。

**思考**

每次找当前需要符合 si 的 pj ，尝试把 pj 移动到 pi ，两种移动方法，冒泡和直接 pi 和 pj 交换，取决于 pi 在 s 的位置是否大于 j

不行！连样例都过不去。

看了题解。

首先，将目标数组看成有序数列，然后对应数字映射成有序数列的数字，是显然的，也方便思考。

然后，从 1 到 n ，考虑如果这个数 i 不在正确的位置，那 i 前面一定有比 i 当前位置所对应的数大的数占据了前面的位置，和这样的数交换是必须的（有些数字虽然比 i 大，但没有比 i 当前的位置大，这样的数不能和 i 交换）

然后对每个数都这样做即可

而代价呢，可以看作每个数都应该从 p[i] 回到 i ，代价是 abs(i - p[i]) ，但交换的过程其实一次换了两个数，相当于出一份代价，做了两个数的事，所以应是总代价 / 2
