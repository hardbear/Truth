# Summary

![Progress](http://progressed.io/bar/3?title=Difficulty:2400|Solved:<1000)


|　　一　　|　　二　　|　　三　　|　　四　　|　　五　　|　　六　　|　　日　　|
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|      |      |  1   | 2 |  3   |  4   |  5   |
|      |      |      |  ✔2  |      |  ✔1  |      |
|  6   |  7   |  8   |  9   |  10  |  11  |  12  |
|      |      |      |      |      |      |      |
|  13  |  14  |  15  |  16  |  17  |  18  |  19  |
|      |      |      |      |      |      |      |
|  20  |  21  |  22  |  23  |  24  |  25  |  26  |
|      |      |      |      |      | ⭐ |      |
|  27  |  28  |  29  |  30  |  31  |      |      |
|      |      |      |      |      |      |      |

---

# Draft

## 【Difficulty : 2400 | Solved : < 1000】

### 2019.05.04

#### ✔ Codeforces 1107G (ST表 + 单调栈)

**题意**

求区间 L 和 R 使得 (R - L + 1) * a - c(R, L) - maxd(R, L) 最大

**思考**

1. 预处理 ans = max(ans, a[i] - c[i], 0)
2. dd[i] = d[i] - d[i-1]
3. 对于每个 i ，找到左右两边第一个 dd[j] > dd[i] ，即每个 i 对应一个 l[i]，r[i]
4. 预处理 pre[i] = pre[i-1] + a - c[i]
5. 以 dd[i] 为最大值 maxd，在 l[i] 和 r[i] 的范围内找最大和最小的 pre
6. 在纸上画了应询问的区间

**总结**

ST 表区间涉及端点 0 ，但板子没考虑端点 0

---

### 2019.05.02

#### ✔ Codeforces 145E (线段树)

**题意**

长度为 n 的字符串，只由 4 和 7 组成。

m 次操作：

1. 区间 [l, r] 内，4 变 7，7 变 4
2. 求整个字符串的最长非严格上升子序列，并输出长度

**思考**

本来没想法，百度，看到关键词，线段树，没看题解！就会做了！

---

#### ✔ Codeforces 584E (排列组合 + 构造)

**题意**

两个排列 p 和 s ，每次交换 pi 和 pj ，花费 abs(i-j) ，求最少花费使 p 变成 s ，且输出方案。

**思考**

每次找当前需要符合 si 的 pj ，尝试把 pj 移动到 pi ，两种移动方法，冒泡和直接 pi 和 pj 交换，取决于 pi 在 s 的位置是否大于 j

不行！连样例都过不去。

看了题解。

首先，将目标数组看成有序数列，然后对应数字映射成有序数列的数字，是显然的，也方便思考。

然后，从 1 到 n ，考虑如果这个数 i 不在正确的位置，那 i 前面一定有比 i 当前位置所对应的数大的数占据了前面的位置，和这样的数交换是必须的（有些数字虽然比 i 大，但没有比 i 当前的位置大，这样的数不能和 i 交换）

然后对每个数都这样做即可

而代价呢，可以看作每个数都应该从 p[i] 回到 i ，代价是 abs(i - p[i]) ，但交换的过程其实一次换了两个数，相当于出一份代价，做了两个数的事，所以应是总代价 / 2
